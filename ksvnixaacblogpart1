Nix - (AaC) Anything as Code:
 Shells, Packages, Containers, Systems & More - All Reproducible, Declarative, and Reliable
1) Modern Chaos:
Throughout the history we have solved a lot of difficulties through growing paradigms, innovative tools, strategies etc. Now we are in the era of AI too. Yet Still we have this decades old problem somehow:
I used to keep a README full of setup steps.
Then I had a Makefile. Then a Dockerfile.
Then a setup.sh, a requirements.txt, and a ci.yml.

And yet, stuff still broke.

Someone would clone the repo and ask:

"What version of Python does this need?"
"Do I install that with Brew or Pipenv?"
"Why doesn't the Docker build work on my machine?"
In today's fragmented tooling landscape, most projects rely on multiple moving parts: language-specific package managers, container runtimes, system setup scripts, CI configurations, and more. Even at the age of AI, but still facing these decades old problem. The reason for all these are the follows:
1) Divergent System: (Known state to Unknown state)
1.1)Everything Imperative: We do instruct how to get things done rather than demanding what exactly u need to the precisely core. Imagine asking someone to make pasta. Everyone does it differently though the ingredients are same. Very careful instructions might work, but not for the software deployments where minute difference changes/breaks things. Somehow we got used and adjusted to this nature a lot, because we troubleshoot it and it works that time. But then, as the modern and future practices grow and scale everyday, this approach makes the hell seep through these small cracks and make portable VMs, container or any type of deplyment a painful process constantly or occasionally requiring intervention costing not just cost but also the productivity and confidence in the deployment pipeline. 
Solution for problem 1.1: Declarative : One solution became popular with programs are config files instead of scripts. This solves the imperative problem via making things Declarative. Declarative works because 
instead of instructing how to achieve things, you say what you want precisely.
 This simple nature made things Atomic, which gave us only 2 states, either everything is applied or nothing. This helped us from the headache of reverting things to where they were if the scripts fail in between. Making maintenance a lot easier and portable which means, sharing the same config to other machine / user makes it work similarly. So, Declarative paradigm gave these Advantages: Portable, Atomic, little Reproducibility and Tracked Changes at a glance from previous config.
Alright, now we have solved the problem for a particular app specific problem and this paradigm is followed for decades solving a lot of scenarios. But still, the diverse toolchain, language specific package managers all doesn't follow the declarative paradigm. Even if they all follow, the problem isn't solved there. Because the environment on which they all work and depend isn't the same. Which brings us to the problem 
1.2) Dependency hell:
Reason 1) TLDR : It's the culprit Imperative again
Every machine starts diverging from their initial state as we start installing programs, running scripts etc etc. So 100 different system even if started and maintained the same way it won't be the same after some point. So at some point we either lose track of changes  or even if we track the change the programs it depend on might vary and the scripts won't always work the same. One way is to adjust the script according to the newer version of OS or packages everytime it changes. That's just temporarily filling the cracks, not a perfect solution and also a headache to maintain and rollback if the script fails midway because of the nature of script.
Reason 2) Existing nature of the Package release and management models everywhere.
In most operating systems and languages, dependencies are managed globally. That means when you install a package, it often gets placed in a shared system path - like /usr/lib. And traditional package managers assume there's one "correct" state/version for the whole system. But in reality, every project might need a slightly different set of tools, even if same tool the versions might vary , and even if same version the flags might vary. Modern programs became super customized specific to their needs, so the traditional globally managed package managers doesn't allow 2 different versions of python(python 3.7 and 3.10.) to exist peacefully, needless to say about about customized versions. And even if we somehow managed to install both side by side, again their dependencies might vary creating another clash between C versions a and b. Some package managers include virtual environment and packaging for their own language specific needs. Eg: virtualenv for python. But still the python versions coexisting problem exists and of course multiple languages having multiple such package managers only makes things complex to adopt the ecosystem giving additional overhead of learning and maintaining. This brings the popular problem, "It works on my machine" whereas not in others.
Containers: 
The actual problem lies in this package management level. VM is a big overhead but ready solution. So people started to solve things from the VMs POV and made containers. Container itself is a neat alternative for VMs giving more benefits than a VM. Yes, great. Now people who thought VM(virtualising hardware) as overhead started accepting the Container(virtualising kernel) as a better solution. Containers are used to solve the VMs but still an overhead for packaging and development environments.
Don't get me wrong, containers are a great way for deployments considering that's the only proper way for isolation other than VMs now. And the whole world is approaching towards docker and made their DevOps or any workflow that way. This seems to solve the dependency hell, but still did not solve the imperative small cracks I mentioned at the start. Especially the Dockerfile.
Why Dockerfile is not good? (Guess the culprit again)
Let's have a very basic dockerfile example:
FROM ubuntu:latest
RUN apt-get update && \
 apt-get install -y curl wget && rm -rf /var/lib/apt/lists/*
WORKDIR /app
COPY . .
CMD ["curl" "--version"]
Dockerfile just again is another imperative thing. Which we just tell some instructions to arrive at a solution(Imperative). Now if u make 100 docker images from this file, all have the same environment right? Nope. If u create an OCI image with dockerfile today and after some months or years the 2 images vary because , again we use traditional package managers whose repo maintainers might drop certain version because of end of LTS or maybe they might have deleted wget or curl from their repo and needless to say the change in their versions. One clever way is to make a package for every version commit in the source code. But all these traditional package managers ship the binaries they have already built. So it's not storage efficient to keep GBs or TBs of data for different version of a single package curl. And pinning the version in these commands is tedious and of course won't work the same after months or years if something in the repo changed. And all the problems we mentioned earlier still lives inside this container. Now instead of solving these imperative cracks in each machine, we are now solving it inside containers. For the sake of isolation we are trading it with overhead of maintaining stuffs and dockerfille just gives it's own imperative cracks to maintain. Needless to say the manual adjustments to make your local and CI environment in sync. TLDR: Docker is okayish, but dockerfile isn't at all.
So how do we solve this decades of problem we face in every stage of SDLC, CICD, Deployments etc?
 Is there any actual practical stable reliable ready solution available to tackle literally all these changes faced in IT?
Even if there is one, how many toolchain does it take to solve all these?
What would the world look like if we can actually reliably say "It works on my machine"?
Instead of accepting the overhead of maintaining the cracks and trading off cracks with isolation etc, is there any such omnipotent like solution to actually solve all these?
The ultimate solution to all these is
Nix. The one dependency solution.
Behold the power of Nix and how it changes the world in the history of IT.
